/*
 * Finite State Machine using C++ Classes

 * Simulates a security system with 4 states:
 *   GREEN: no alarms or clear button being held, light green LED
 *   YELLOW: alarm detected, light yellow LED
 *   Y_PAUSE: pausing with yellow LED on before transition to red LED
 *   RED: alarm detected and full alarm
 *   
 *   alarms are simulated with a button switch  (ALARM)
 *   alarms are cleared with a separate button switch (CLEAR)
 *   the pause before transition to the red state is user specified
 *    
 * Tested with Energia V18 on a F5529 LaunchPad
 * Released into the public domain
 * F. Milburn   January 2017
 */

const int GREEN = 0;       // all possible states
const int YELLOW = 1;
const int Y_PAUSE = 2;
const int RED = 3;

const int NONE = 0;        // all possible input combinations from 2 buttons
const int ALARM = 1; 
const int CLEAR = 2;  
const int BOTH = 3; 

// structure for finite state machine
struct state_t{
  int nextState[4];
};

class Security{
  int gPin;                // green LED
  int yPin;                // yellow LED
  int rPin;                // red LED
  int aPin;                // alarm pin
  int cPin;                // clear pin
  unsigned long pTime;     // pause before moving from yellow --> red (mSec)
  boolean paused;          // timed condition internal to state
  unsigned long pauseUntil;// pause from yellow --> red before changing state
  int state;               // current state
  int lastState;           // last state
  int input;               // current input
  
  public:
  // Constructor ---------------------------------------------------------------
  Security(int alarmPin, int clearPin, int greenPin, int yellowPin, int redPin, 
  unsigned long pauseTime){
    
    gPin = greenPin;
    yPin = yellowPin;
    rPin = redPin;
    aPin = alarmPin;
    cPin = clearPin;
    pTime = pauseTime;

    pinMode(aPin, INPUT_PULLUP); // initialize inputs
    pinMode(cPin, INPUT_PULLUP);
  
    pinMode(gPin, OUTPUT);       // initialize outputs
    digitalWrite(gPin, LOW);
    pinMode(yPin, OUTPUT);
    digitalWrite(yPin, LOW);
    pinMode(rPin, OUTPUT);
    digitalWrite(rPin, LOW);

    input = CLEAR;               // place into initial state
    paused = false;
    lastState = GREEN;
    state = GREEN;
    do_Grn();                    
  }
  // Update --------------------------------------------------------------------
  int Update(){
    if ((lastState != state) || paused){  // check for a change in state
      lastState = state;
      switch (state){
        case GREEN:
          do_Grn();
          break;
        case YELLOW:
          do_Yel();
          break;
        case Y_PAUSE:
          do_YelP();
          break;
        case RED:
          do_Red();
          break;
      }
    }
    input = read_Input();
    state = eval_State();
    return state;
  }
  // Green ---------------------------------------------------------------------
  void do_Grn(){
    digitalWrite(gPin, HIGH);
    digitalWrite(yPin, LOW);
    digitalWrite(rPin, LOW);
    paused = false;
  }
  // Yellow --------------------------------------------------------------------
  void do_Yel(){
    digitalWrite(gPin, LOW);
    digitalWrite(yPin, HIGH);
    digitalWrite(rPin, LOW);
    paused = false;
  }
  // Yellow pause to red -------------------------------------------------------
  void do_YelP(){
    // check if internal transition condition (time) is met
    if (millis() <= pauseUntil){
      paused = true;
    }
    else{
      paused = false;
    }
  }
  // Red -----------------------------------------------------------------------
  void do_Red(){
    digitalWrite(gPin, LOW);
    digitalWrite(yPin, LOW);
    digitalWrite(rPin, HIGH);
    paused = false;
  }
  // Read Input ----------------------------------------------------------------
  int read_Input(void){
    //  aPin     cPin     returns
    //   0         0         NONE
    //   1         0         ALARM
    //   0         1         CLEAR
    //   1         1         BOTH
    int alarm_state = digitalRead(aPin);
    int clear_state = digitalRead(cPin);
    if ((alarm_state  == 1) && (clear_state == 1)){
      return NONE;
    }
    else if ((alarm_state == 0) && (clear_state == 1)){
      return ALARM;
    }
    else if ((alarm_state == 1) && (clear_state == 0)){
      return CLEAR;
    }
    else{
      return BOTH;
    }
  }
  // Evaluate State ------------------------------------------------------------
  int eval_State(void){

    // define the finite state machine
    state_t security_state[] = {
    // --------- next states --------- 
    // NONE        ALARM     BOTH    CLEAR   
    // ---------  ---------  ------  ------  
      {GREEN,     YELLOW,    GREEN,  GREEN},     // GREEN
      {Y_PAUSE,   Y_PAUSE,   GREEN,  GREEN},     // YELLOW
      {RED,       RED,       GREEN,  GREEN},     // YELLOW_PAUSE
      {RED,       RED,       GREEN,  GREEN},     // RED
    };
    if (!paused || (input == CLEAR) || (input == BOTH)){
      state = security_state[state].nextState[input];
      if (state == Y_PAUSE){
        pauseUntil = millis() + pTime;           // transition condition        
      }
    }
    return state;
  }
};

// Energia Sketch -------------------------------------------------------------
// Call the constructor with pin numbers for alarm and clear buttons, then 
// green, yellow, and red LEDs, then specify the pause length in mSec.
Security zone_1( 6,  7,  8,  9, 10, 4000); 
Security zone_2(35, 34, 33, 32, 31, 2000);
Security zone_3(15, 14, 13, 12, 11, 3000);

void setup() {

}

void loop() {
  zone_1.Update();
  zone_2.Update();
  zone_3.Update();
}
